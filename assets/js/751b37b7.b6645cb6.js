"use strict";(self.webpackChunkdeveloperdocs=self.webpackChunkdeveloperdocs||[]).push([[771],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return d}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),p=c(n),d=a,h=p["".concat(l,".").concat(d)]||p[d]||u[d]||s;return n?r.createElement(h,o(o({ref:t},m),{},{components:n})):r.createElement(h,o({ref:t},m))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var c=2;c<s;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2643:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return u}});var r=n(7462),a=n(3366),s=(n(7294),n(3905)),o=["components"],i={title:"Hermes Bar",description:"How does the HermesBar contract work? Why is it written that way?",author:"Hermes Team",sidebar:!0,tags:["solidity","hermes","staking"],skill:"intermediate",published:new Date("2022-05-14T00:00:00.000Z"),lang:"en",sidebar_position:9},l="HermesBar",c={unversionedId:"Staking/Hermes Bar",id:"Staking/Hermes Bar",title:"Hermes Bar",description:"How does the HermesBar contract work? Why is it written that way?",source:"@site/docs/Staking/Hermes Bar.md",sourceDirName:"Staking",slug:"/Staking/Hermes Bar",permalink:"/Developer-docs/docs/Staking/Hermes Bar",draft:!1,tags:[{label:"solidity",permalink:"/Developer-docs/docs/tags/solidity"},{label:"hermes",permalink:"/Developer-docs/docs/tags/hermes"},{label:"staking",permalink:"/Developer-docs/docs/tags/staking"}],version:"current",sidebarPosition:9,frontMatter:{title:"Hermes Bar",description:"How does the HermesBar contract work? Why is it written that way?",author:"Hermes Team",sidebar:!0,tags:["solidity","hermes","staking"],skill:"intermediate",published:"2022-05-14T00:00:00.000Z",lang:"en",sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"StableHermesStaking",permalink:"/Developer-docs/docs/Staking/StableHermesStaking"}},m={},u=[{value:"Data and Control Flows",id:"data-and-control-flows",level:2},{value:"HermesBar.sol",id:"hermesbarsol",level:3},{value:"Setup Functions",id:"setup-functions",level:4},{value:"Externally Accessible Functions",id:"externally-accessible-functions",level:4},{value:"enter",id:"enter",level:5},{value:"leave",id:"leave",level:5}],p={toc:u};function d(e){var t=e.components,n=(0,a.Z)(e,o);return(0,s.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"hermesbar"},"HermesBar"),(0,s.kt)("p",null,"HermesBar is a stacking contract that permit you invest some money, though HERMES token and gain xHERMESS in exchange."),(0,s.kt)("p",null,"The longer the token stays in the contract, the greater the possibility won. "),(0,s.kt)("p",null,"The user will be able to request their tokens at any time and receive the reward."),(0,s.kt)("h2",{id:"data-and-control-flows"},"Data and Control Flows"),(0,s.kt)("p",null,"This is the flow of data and control that happens when you perform the three main actions of HermesBar:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"The caller deposit some Hermes and gain some xHERMES. Locks Hermes and mints xHermes."),(0,s.kt)("li",{parentName:"ol"},"The caller can take them tokens any moment"),(0,s.kt)("li",{parentName:"ol"},"Claim back your HERMESs. Unlocks the staked + gained Hermes and burns xHermes")),(0,s.kt)("h3",{id:"hermesbarsol"},"HermesBar.sol"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/Hermes-defi/hermes-swap/blob/main/contracts/HermesBar.sol"},"This contract")," implements the\nHermesSwap's staking."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},'pragma solidity 0.6.12;\ncontract HermesBar is ERC20("HermesBar", "xHERMES") {\n')),(0,s.kt)("p",null,'Start the contract by entering the token name ("HermesBar") and token symbol ("xHERMES").'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"    using SafeMath for uint256;\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"https://docs.openzeppelin.com/contracts/2.x/api/math"},"SafeMathHermes library")," is used to avoid overflows and\nunderflows. This is important because otherwise we might end up with a situation where a value should be ",(0,s.kt)("inlineCode",{parentName:"p"},"-1"),",\nbut is instead ",(0,s.kt)("inlineCode",{parentName:"p"},"2^256-1"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"    IERC20 public hermes;\n")),(0,s.kt)("p",null,"The Hermes token."),(0,s.kt)("h4",{id:"setup-functions"},"Setup Functions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"    constructor(IERC20 _hermes) public {\n        hermes = _hermes;\n    }\n")),(0,s.kt)("p",null,"This contract inherits from ",(0,s.kt)("inlineCode",{parentName:"p"},"IERC20"),", which provides the the ERC-20 functions for the liquidity tokens."),(0,s.kt)("h4",{id:"externally-accessible-functions"},"Externally Accessible Functions"),(0,s.kt)("h5",{id:"enter"},"enter"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"   function enter(uint256 _amount) public {\n       uint256 totalHermes = hermes.balanceOf(address(this));\n       uint256 totalShares = totalSupply();       \n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'This function is called when a liquidity provider adds liquidity to the contract ("xHERMES").\nGets the amount of Hermes locked in the contract and gets the amount of xHermes in existence\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"   if (totalShares == 0 || totalHermes == 0) {\n            _mint(msg.sender, _amount);\n        }\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"If no xHermes exists, mint it 1:1 to the amount put in\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"   else {\n            uint256 what = _amount.mul(totalShares).div(totalHermes);\n            _mint(msg.sender, what);\n        }\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Calculate and mint the amount of xHermes the Hermes is worth. The ratio will change overtime, as xHermes is burned/minted and Hermes deposited + gained from fees / withdrawn.\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"   hermes.transferFrom(msg.sender, address(this), _amount);\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Lock the Hermes in the contract\n")),(0,s.kt)("h5",{id:"leave"},"leave"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"   function leave(uint256 _share) public {\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'This function is called when a liquidity provider removes liquidity to from contract ("HERMES").\nUnlocks the staked + gained Hermes and burns xHermes\nInform how much Hermes will be withdrawn. You can remove all or part of it.\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"   uint256 totalShares = totalSupply();\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Gets the amount of xHermes in existence\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"   uint256 what = _share.mul(hermes.balanceOf(address(this))).div(totalShares);\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Calculates the amount of Hermes the xHermes is worth\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"   _burn(msg.sender, _share);\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Burn the requested tokens \n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},"   hermes.transfer(msg.sender, what);\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Transfer the tokens back\n")))}d.isMDXComponent=!0}}]);