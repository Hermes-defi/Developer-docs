"use strict";(self.webpackChunkdeveloperdocs=self.webpackChunkdeveloperdocs||[]).push([[197],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return k}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),d=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=d(e.components);return a.createElement(i.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=d(t),k=r,m=p["".concat(i,".").concat(k)]||p[k]||c[k]||o;return t?a.createElement(m,l(l({ref:n},u),{},{components:t})):a.createElement(m,l({ref:n},u))}));function k(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,l=new Array(o);l[0]=p;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var d=2;d<o;d++)l[d]=t[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},835:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return i},default:function(){return k},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return c}});var a=t(7462),r=t(3366),o=(t(7294),t(3905)),l=["components"],s={title:"SingleStakingPool",description:"How does the SingleStakingPool contract work? Why is it written that way?",author:"Hermes Team",sidebar:!0,tags:["solidity","hermes","staking"],skill:"intermediate",published:new Date("2022-05-14T00:00:00.000Z"),lang:"en",sidebar_position:7},i="SingleStakingPool",d={unversionedId:"Staking/SingleStakingPool",id:"Staking/SingleStakingPool",title:"SingleStakingPool",description:"How does the SingleStakingPool contract work? Why is it written that way?",source:"@site/docs/Staking/SingleStakingPool.md",sourceDirName:"Staking",slug:"/Staking/SingleStakingPool",permalink:"/Developer-docs/docs/Staking/SingleStakingPool",draft:!1,tags:[{label:"solidity",permalink:"/Developer-docs/docs/tags/solidity"},{label:"hermes",permalink:"/Developer-docs/docs/tags/hermes"},{label:"staking",permalink:"/Developer-docs/docs/tags/staking"}],version:"current",sidebarPosition:7,frontMatter:{title:"SingleStakingPool",description:"How does the SingleStakingPool contract work? Why is it written that way?",author:"Hermes Team",sidebar:!0,tags:["solidity","hermes","staking"],skill:"intermediate",published:"2022-05-14T00:00:00.000Z",lang:"en",sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Vesting",permalink:"/Developer-docs/docs/Vesting"},next:{title:"StableHermesStaking",permalink:"/Developer-docs/docs/Staking/StableHermesStaking"}},u={},c=[{value:"SingleStakingPool.sol",id:"singlestakingpoolsol",level:3},{value:"Events",id:"events",level:4},{value:"Setup Functions",id:"setup-functions",level:4},{value:"Externally Accessible Functions",id:"externally-accessible-functions",level:4},{value:"getMultiplier",id:"getmultiplier",level:5},{value:"setBonusEndBlock",id:"setbonusendblock",level:5},{value:"pendingReward",id:"pendingreward",level:5},{value:"updatePool",id:"updatepool",level:5},{value:"deposit",id:"deposit",level:5},{value:"withdraw",id:"withdraw",level:5},{value:"rewardBalance",id:"rewardbalance",level:5},{value:"depositRewards",id:"depositrewards",level:5},{value:"totalStakeTokenBalance",id:"totalstaketokenbalance",level:5},{value:"getStakeTokenFeeBalance",id:"getstaketokenfeebalance",level:5},{value:"setRewardPerBlock",id:"setrewardperblock",level:5},{value:"skimStakeTokenFees",id:"skimstaketokenfees",level:5},{value:"emergencyWithdraw",id:"emergencywithdraw",level:5},{value:"emergencyRewardWithdraw",id:"emergencyrewardwithdraw",level:5},{value:"depositRewards",id:"depositrewards-1",level:5},{value:"Internal functions",id:"internal-functions",level:5},{value:"safeTransferReward",id:"safetransferreward",level:5}],p={toc:c};function k(e){var n=e.components,t=(0,r.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"singlestakingpool"},"SingleStakingPool"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Hermes-defi/hermes-swap/blob/main/contracts/SingleStakingPool.sol"},"This contract")," is a representation of Single-stake. Single-stake pools is where only one type of token is needed to stake. No LP token-making is required, but the concept is similar to making a liquidity token (LP), and staking that LP in a farm to earn other tokens. "),(0,o.kt)("h3",{id:"singlestakingpoolsol"},"SingleStakingPool.sol"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"contract StakingPool is Ownable, Initializable {\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  using SafeERC20 for IERC20;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  struct UserInfo {\n          uint256 amount;     // How many LP tokens the user has provided.\n          uint256 rewardDebt; // Reward debt. See explanation below.\n      }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Info of each user - How many LP tokens the user has provided and Reward debt\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  struct PoolInfo {\n        IERC20 lpToken;           // Address of LP token contract.\n        uint256 allocPoint;       // How many allocation points assigned to this pool. Rewards to distribute per block.\n        uint256 lastRewardBlock;  // Last block number that Rewards distribution occurs.\n        uint256 accRewardTokenPerShare; // Accumulated Rewards per share, times 1e30. See below.\n    }\n\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  IERC20 public STAKE_TOKEN;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"The stake token\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  IERC20 public REWARD_TOKEN\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"The reward token\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  uint256 public rewardPerBlock;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Reward tokens created per block.\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  uint256 public totalStaked = 0;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Keep track of number of tokens staked in case the contract earns reflect fees\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  PoolInfo public poolInfo;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Info of each pool.\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  mapping (address => UserInfo) public userInfo;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Info of each user that stakes LP tokens.\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  uint256 private totalAllocPoint = 0;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Total allocation poitns. Must be the sum of all allocation points in all pools.\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  uint256 public startBlock;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"The block number when Reward mining starts.\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  uint256 public bonusEndBlock;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"The block number when mining ends.\n")),(0,o.kt)("h4",{id:"events"},"Events"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"event Deposit(address indexed user, uint256 amount);\n    event DepositRewards(uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 amount);\n    event SkimStakeTokenFees(address indexed user, uint256 amount);\n    event LogUpdatePool(uint256 bonusEndBlock, uint256 rewardPerBlock);\n    event EmergencyRewardWithdraw(address indexed user, uint256 amount);\n    event EmergencySweepWithdraw(address indexed user, IERC20 indexed token, uint256 amount);\n")),(0,o.kt)("h4",{id:"setup-functions"},"Setup Functions"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"    function initialize(\n        IERC20 _stakeToken,\n        IERC20 _rewardToken,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _bonusEndBlock\n    ) external initializer\n    {\n        STAKE_TOKEN = _stakeToken;\n        REWARD_TOKEN = _rewardToken;\n        rewardPerBlock = _rewardPerBlock;\n        startBlock = _startBlock;\n        bonusEndBlock = _bonusEndBlock;\n\n        // staking pool\n        poolInfo = PoolInfo({\n        lpToken: _stakeToken,\n        allocPoint: 1000,\n        lastRewardBlock: startBlock,\n        accRewardTokenPerShare: 0\n        });\n\n        totalAllocPoint = 1000;\n    }\n")),(0,o.kt)("h4",{id:"externally-accessible-functions"},"Externally Accessible Functions"),(0,o.kt)("h5",{id:"getmultiplier"},"getMultiplier"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"   function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        if (_to <= bonusEndBlock) {\n            return _to - _from;\n        } else if (_from >= bonusEndBlock) {\n            return 0;\n        } else {\n            return bonusEndBlock - _from;\n        }\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Return reward multiplier over the given _from to _to block.\n")),(0,o.kt)("h5",{id:"setbonusendblock"},"setBonusEndBlock"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"   function setBonusEndBlock(uint256 _bonusEndBlock) external onlyOwner {\n        require(_bonusEndBlock > bonusEndBlock, 'new bonus end block must be greater than current');\n        bonusEndBlock = _bonusEndBlock;\n        emit LogUpdatePool(bonusEndBlock, rewardPerBlock);\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"_bonusEndBlock The block when rewards will end\n")),(0,o.kt)("h5",{id:"pendingreward"},"pendingReward"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"   function pendingReward(address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        uint256 accRewardTokenPerShare = poolInfo.accRewardTokenPerShare;\n        if (block.number > poolInfo.lastRewardBlock && totalStaked != 0) {\n            uint256 multiplier = getMultiplier(poolInfo.lastRewardBlock, block.number);\n            uint256 tokenReward = multiplier * rewardPerBlock * poolInfo.allocPoint / totalAllocPoint;\n            accRewardTokenPerShare = accRewardTokenPerShare + (tokenReward * 1e30 / totalStaked);\n        }\n        return user.amount * accRewardTokenPerShare / 1e30 - user.rewardDebt;\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"View function to see pending Reward on frontend.\n")),(0,o.kt)("h5",{id:"updatepool"},"updatePool"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"   function updatePool() public {\n        if (block.number <= poolInfo.lastRewardBlock) {\n            return;\n        }\n        if (totalStaked == 0) {\n            poolInfo.lastRewardBlock = block.number;\n            return;\n        }\n        uint256 multiplier = getMultiplier(poolInfo.lastRewardBlock, block.number);\n        uint256 tokenReward = multiplier * rewardPerBlock * poolInfo.allocPoint / totalAllocPoint;\n        poolInfo.accRewardTokenPerShare = poolInfo.accRewardTokenPerShare + (tokenReward * 1e30 / totalStaked);\n        poolInfo.lastRewardBlock = block.number;\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Update reward variables of the given pool to be up-to-date.\n")),(0,o.kt)("h5",{id:"deposit"},"deposit"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"   function deposit(uint256 _amount) public {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 finalDepositAmount = 0;\n        updatePool();\n        if (user.amount > 0) {\n            uint256 pending = user.amount * poolInfo.accRewardTokenPerShare / 1e30 - user.rewardDebt;\n            if(pending > 0) {\n                uint256 currentRewardBalance = rewardBalance();\n                if(currentRewardBalance > 0) {\n                    if(pending > currentRewardBalance) {\n                        safeTransferReward(address(msg.sender), currentRewardBalance);\n                    } else {\n                        safeTransferReward(address(msg.sender), pending);\n                    }\n                }\n            }\n        }\n        if (_amount > 0) {\n            uint256 preStakeBalance = STAKE_TOKEN.balanceOf(address(this));\n            poolInfo.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n            finalDepositAmount = STAKE_TOKEN.balanceOf(address(this)) - preStakeBalance;\n            user.amount = user.amount + finalDepositAmount;\n            totalStaked = totalStaked + finalDepositAmount;\n        }\n        user.rewardDebt = user.amount * poolInfo.accRewardTokenPerShare / 1e30;\n\n        emit Deposit(msg.sender, finalDepositAmount);\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Deposit staking token into the contract to earn rewards.\nSince this contract needs to be supplied with rewards we are\nsending the balance of the contract if the pending rewards are higher\n@param _amount The amount of staking tokens to deposit\n")),(0,o.kt)("h5",{id:"withdraw"},"withdraw"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'   function withdraw(uint256 _amount) public {\n        UserInfo storage user = userInfo[msg.sender];\n        require(user.amount >= _amount, "withdraw: not good");\n        updatePool();\n        uint256 pending = user.amount * poolInfo.accRewardTokenPerShare / 1e30 - user.rewardDebt;\n        if(pending > 0) {\n            uint256 currentRewardBalance = rewardBalance();\n            if(currentRewardBalance > 0) {\n                if(pending > currentRewardBalance) {\n                    safeTransferReward(address(msg.sender), currentRewardBalance);\n                } else {\n                    safeTransferReward(address(msg.sender), pending);\n                }\n            }\n        }\n        if(_amount > 0) {\n            user.amount = user.amount - _amount;\n            poolInfo.lpToken.safeTransfer(address(msg.sender), _amount);\n            totalStaked = totalStaked - _amount;\n        }\n\n        user.rewardDebt = user.amount * poolInfo.accRewardTokenPerShare / 1e30;\n\n        emit Withdraw(msg.sender, _amount);\n    }\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Withdraw rewards and/or staked tokens. Pass a 0 amount to withdraw only rewards\n@param _amount The amount of staking tokens to withdraw\n")),(0,o.kt)("h5",{id:"rewardbalance"},"rewardBalance"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  \n    function rewardBalance() public view returns (uint256) {\n        uint256 balance = REWARD_TOKEN.balanceOf(address(this));\n        if (STAKE_TOKEN == REWARD_TOKEN)\n            return balance - totalStaked;\n        return balance;\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Obtain the reward balance of this contract\n@return wei balace of conract\n")),(0,o.kt)("h5",{id:"depositrewards"},"depositRewards"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"   function depositRewards(uint256 _amount) external {\n        require(_amount > 0, 'Deposit value must be greater than 0.');\n        REWARD_TOKEN.safeTransferFrom(address(msg.sender), address(this), _amount);\n        emit DepositRewards(_amount);\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Deposit Rewards into contract   \n")),(0,o.kt)("h5",{id:"totalstaketokenbalance"},"totalStakeTokenBalance"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  function totalStakeTokenBalance() public view returns (uint256) {\n        if (STAKE_TOKEN == REWARD_TOKEN)\n            return totalStaked;\n        return STAKE_TOKEN.balanceOf(address(this));\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"}," Obtain the stake balance of this contract\n")),(0,o.kt)("h5",{id:"getstaketokenfeebalance"},"getStakeTokenFeeBalance"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  function getStakeTokenFeeBalance() public view returns (uint256) {\n        return STAKE_TOKEN.balanceOf(address(this)) - totalStaked;\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Obtain the stake token fees (if any) earned by reflect token\n")),(0,o.kt)("h5",{id:"setrewardperblock"},"setRewardPerBlock"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  function setRewardPerBlock(uint256 _rewardPerBlock) external onlyOwner {\n        rewardPerBlock = _rewardPerBlock;\n        emit LogUpdatePool(bonusEndBlock, rewardPerBlock);\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"@param _rewardPerBlock The amount of reward tokens to be given per block\n")),(0,o.kt)("h5",{id:"skimstaketokenfees"},"skimStakeTokenFees"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  function skimStakeTokenFees() external onlyOwner {\n        uint256 stakeTokenFeeBalance = getStakeTokenFeeBalance();\n        STAKE_TOKEN.safeTransfer(msg.sender, stakeTokenFeeBalance);\n        emit SkimStakeTokenFees(msg.sender, stakeTokenFeeBalance);\n    }\n\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Remove excess stake tokens earned by reflect fees\n")),(0,o.kt)("h5",{id:"emergencywithdraw"},"emergencyWithdraw"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  function emergencyWithdraw() external {\n        UserInfo storage user = userInfo[msg.sender];\n        poolInfo.lpToken.safeTransfer(address(msg.sender), user.amount);\n        totalStaked = totalStaked - user.amount;\n        user.amount = 0;\n        user.rewardDebt = 0;\n        emit EmergencyWithdraw(msg.sender, user.amount);\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Withdraw without caring about rewards. EMERGENCY ONLY.\n")),(0,o.kt)("h5",{id:"emergencyrewardwithdraw"},"emergencyRewardWithdraw"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  function emergencyRewardWithdraw(uint256 _amount) external onlyOwner {\n        require(_amount <= rewardBalance(), 'not enough rewards');\n        // Withdraw rewards\n        safeTransferReward(address(msg.sender), _amount);\n        emit EmergencyRewardWithdraw(msg.sender, _amount);\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Withdraw reward. EMERGENCY ONLY.\n")),(0,o.kt)("h5",{id:"depositrewards-1"},"depositRewards"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'  function sweepToken(IERC20 token) external onlyOwner {\n        require(address(token) != address(STAKE_TOKEN), "can not sweep stake token");\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(msg.sender, balance);\n        emit EmergencySweepWithdraw(msg.sender, token, balance);\n    }\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"A public function to sweep accidental BEP20 transfers to this contract.\nTokens are sent to owner\n@param token The address of the BEP20 token to sweep\n")),(0,o.kt)("h5",{id:"internal-functions"},"Internal functions"),(0,o.kt)("h5",{id:"safetransferreward"},"safeTransferReward"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function safeTransferReward(address _to, uint256 _amount) internal {\n        REWARD_TOKEN.safeTransfer(_to, _amount);\n    }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"@param _to address to send reward token to\n@param _amount value of reward token to transfer\n")))}k.isMDXComponent=!0}}]);