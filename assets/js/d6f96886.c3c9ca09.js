"use strict";(self.webpackChunkdeveloperdocs=self.webpackChunkdeveloperdocs||[]).push([[832],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,u=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(n),m=i,y=p["".concat(u,".").concat(m)]||p[m]||c[m]||a;return n?r.createElement(y,o(o({ref:t},d),{},{components:n})):r.createElement(y,o({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=p;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var l=2;l<a;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},3647:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return u},default:function(){return m},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return c}});var r=n(7462),i=n(3366),a=(n(7294),n(3905)),o=["components"],s={title:"Liquidity TransferService",description:"How does the LiquidityTransferService contract work? Why is it written that way?",author:"Hermes Team",sidebar:!0,tags:["solidity","hermes","staking"],skill:"intermediate",published:new Date("2022-05-14T00:00:00.000Z"),lang:"en",sidebar_position:11},u="LiquidityTransferService - Move fees",l={unversionedId:"Liquidity Transfer",id:"Liquidity Transfer",title:"Liquidity TransferService",description:"How does the LiquidityTransferService contract work? Why is it written that way?",source:"@site/docs/Liquidity Transfer.md",sourceDirName:".",slug:"/Liquidity Transfer",permalink:"/Developer-docs/docs/Liquidity Transfer",draft:!1,tags:[{label:"solidity",permalink:"/Developer-docs/docs/tags/solidity"},{label:"hermes",permalink:"/Developer-docs/docs/tags/hermes"},{label:"staking",permalink:"/Developer-docs/docs/tags/staking"}],version:"current",sidebarPosition:11,frontMatter:{title:"Liquidity TransferService",description:"How does the LiquidityTransferService contract work? Why is it written that way?",author:"Hermes Team",sidebar:!0,tags:["solidity","hermes","staking"],skill:"intermediate",published:"2022-05-14T00:00:00.000Z",lang:"en",sidebar_position:11},sidebar:"tutorialSidebar",previous:{title:"Distributor",permalink:"/Developer-docs/docs/Distributor"},next:{title:"SingleStakingPool",permalink:"/Developer-docs/docs/Staking/SingleStakingPool"}},d={},c=[{value:"Data and Control Flows",id:"data-and-control-flows",level:2},{value:"LiquidityTransferService.sol",id:"liquiditytransferservicesol",level:3},{value:"Setup Functions",id:"setup-functions",level:4},{value:"Events",id:"events",level:4},{value:"Externally Accessible Functions",id:"externally-accessible-functions",level:4},{value:"enter",id:"enter",level:5},{value:"Internal functions",id:"internal-functions",level:5},{value:"getLiquidityValue",id:"getliquidityvalue",level:5},{value:"computeLiquidityValue",id:"computeliquidityvalue",level:5}],p={toc:c};function m(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"liquiditytransferservice---move-fees"},"LiquidityTransferService - Move fees"),(0,a.kt)("p",null,"LiquidityTransferService is contract to move liquidity from A to B. "),(0,a.kt)("h2",{id:"data-and-control-flows"},"Data and Control Flows"),(0,a.kt)("p",null,"This is the flow of data and control that happens when you perform the three main actions of LiquidityTransferService:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Remove all liquidity from this contract"),(0,a.kt)("li",{parentName:"ol"},"Apove and transfer all liquidity to pairs on routerDst")),(0,a.kt)("h3",{id:"liquiditytransferservicesol"},"LiquidityTransferService.sol"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/Hermes-defi/hermes-swap/blob/main/contracts/LiquidityTransfer.sol"},"This contract")," implements the\nHermesSwap's liquidity transfer service. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"pragma solidity 0.6.12;\ncontract LiquidityTransferService {\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    using SafeMath for uint256;\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://docs.openzeppelin.com/contracts/2.x/api/math"},"SafeMathHermes library")," is used to avoid overflows and\nunderflows. This is important because otherwise we might end up with a situation where a value should be ",(0,a.kt)("inlineCode",{parentName:"p"},"-1"),",\nbut is instead ",(0,a.kt)("inlineCode",{parentName:"p"},"2^256-1"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    IHermesRouter02 public routerSrc;\n    IHermesRouter02 public routerDst;\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Interface to tokens on source and destination\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    address public srcPair;\n    address public dstPair;\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    address public tokenA;\n    address public tokenB;\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    uint public slippageBps = 50; // 0.5%\n    address public admin;\n")),(0,a.kt)("h4",{id:"setup-functions"},"Setup Functions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    constructor(\n        address _routerSrc, address _routerDst,\n        address _tokenA, address _tokenB\n    ) public {\n        admin = msg.sender;\n        routerSrc = IHermesRouter02(_routerSrc);\n        routerDst = IHermesRouter02(_routerDst);\n\n        tokenA = _tokenA;\n        tokenB = _tokenB;\n\n        srcPair = IHermesFactory(routerSrc.factory()).getPair(_tokenA, _tokenB);\n        if (srcPair == address(0x0)) {\n            srcPair = IHermesFactory(routerSrc.factory()).createPair(_tokenA, _tokenB);\n        }\n\n        dstPair = IHermesFactory(routerDst.factory()).getPair(_tokenA, _tokenB);\n        if (dstPair == address(0x0)) {\n            dstPair = IHermesFactory(routerDst.factory()).createPair(_tokenA, _tokenB);\n        }\n    }\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Initialize our variables. \n")),(0,a.kt)("h4",{id:"events"},"Events"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"event OnRemoveLiquidity(address user, address pair, uint amountA, uint amountB, uint liquidity);\n\nevent OnAddLiquidity(address user, address pair, uint amountA, uint amountB, uint liquidity);\n\nevent onSlippageBps(uint oldPoints, uint newPoints);\n")),(0,a.kt)("h4",{id:"externally-accessible-functions"},"Externally Accessible Functions"),(0,a.kt)("h5",{id:"enter"},"enter"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'   function setSlippageBps(uint points) external{\n        require(msg.sender == admin, "error, no admin");\n        emit onSlippageBps(slippageBps, points);\n        slippageBps = points;\n    }\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"   function run() external {\n\n        IHermesPair srcPairCtx = IHermesPair(srcPair);\n        uint256 liquidity = srcPairCtx.balanceOf(msg.sender);\n\n        require(liquidity > 0, \"err no src liquidity\");\n        require(srcPairCtx.allowance(msg.sender, address(this)) >= liquidity, \"err allowance\");\n\n        srcPairCtx.transferFrom(msg.sender, address(this), liquidity);\n\n        liquidity = srcPairCtx.balanceOf(address(this));\n\n        (uint256 tokenAAmount, uint256 tokenBAmount) = getLiquidityValue(srcPairCtx,liquidity);\n\n        srcPairCtx.approve(address(routerSrc), liquidity);\n        (uint amountA, uint amountB) = routerSrc.removeLiquidity(\n                tokenA,\n                tokenB,\n                liquidity,\n                tokenAAmount * (10000 - slippageBps) / 10000,\n                tokenBAmount * (10000 - slippageBps) / 10000,\n                address(this), block.timestamp + 60);\n\n        /*\n        console.log('amountA=%s amountB=%s', amountA, amountB);\n        console.log('tokenAAmount=%s tokenBAmount=%s', tokenAAmount, tokenBAmount);\n        console.log('tokenAAmount=%s tokenBAmount=%s',\n            tokenAAmount * (10000 - slippageBps) / 10000,\n            tokenBAmount * (10000 - slippageBps) / 10000);\n        */\n\n        emit OnRemoveLiquidity(msg.sender, srcPair, amountA, amountB, liquidity);\n\n        IHermesERC20 tokenACtx = IHermesERC20(tokenA);\n        IHermesERC20 tokenBCtx = IHermesERC20(tokenB);\n\n        amountA = tokenACtx.balanceOf(address(this));\n        amountB = tokenBCtx.balanceOf(address(this));\n\n        tokenACtx.approve(address(routerDst), amountA);\n        tokenBCtx.approve(address(routerDst), amountB);\n\n        (uint _amountA, uint _amountB, uint _liquidity) =\n        routerDst.addLiquidity(tokenA, tokenB,\n            amountA,\n            amountB,\n            amountA * (10000 - slippageBps) / 10000,\n            amountB * (10000 - slippageBps) / 10000,\n            msg.sender, block.timestamp + 60);\n\n        // by audit recomendation, we should send any dust to user\n\n        uint balanceA = tokenACtx.balanceOf(address(this));\n        if( balanceA > 0 ){\n            tokenACtx.transfer(msg.sender, balanceA);\n        }\n\n        uint balanceB = tokenBCtx.balanceOf(address(this));\n        if( balanceB > 0 ){\n            tokenBCtx.transfer(msg.sender, balanceB);\n        }\n\n        emit OnAddLiquidity(msg.sender, srcPair, _amountA, _amountB, _liquidity);\n\n    }\n")),(0,a.kt)("h5",{id:"internal-functions"},"Internal functions"),(0,a.kt)("h5",{id:"getliquidityvalue"},"getLiquidityValue"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"   function getLiquidityValue(\n        IHermesPair pair,\n        uint256 liquidityAmount\n    ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        (uint256 reservesA, uint256 reservesB) = HermesLibrary.getReserves(routerSrc.factory(), pair.token0(), pair.token1());\n        bool feeOn = IHermesFactory(routerSrc.factory()).feeTo() != address(0);\n        uint kLast = feeOn ? pair.kLast() : 0;\n        uint totalSupply = pair.totalSupply();\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n    }\n")),(0,a.kt)("h5",{id:"computeliquidityvalue"},"computeLiquidityValue"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"   function computeLiquidityValue(\n        uint256 reservesA,\n        uint256 reservesB,\n        uint256 totalSupply,\n        uint256 liquidityAmount,\n        bool feeOn,\n        uint kLast\n    ) internal pure returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        if (feeOn && kLast > 0) {\n            uint rootK = Babylonian.sqrt(reservesA.mul(reservesB));\n            uint rootKLast = Babylonian.sqrt(kLast);\n            if (rootK > rootKLast) {\n                uint numerator1 = totalSupply;\n                uint numerator2 = rootK.sub(rootKLast);\n                uint denominator = rootK.mul(5).add(rootKLast);\n                uint feeLiquidity = FullMath.mulDiv(numerator1, numerator2, denominator);\n                totalSupply = totalSupply.add(feeLiquidity);\n            }\n        }\n        return (reservesA.mul(liquidityAmount) / totalSupply, reservesB.mul(liquidityAmount) / totalSupply);\n    }\n")))}m.isMDXComponent=!0}}]);